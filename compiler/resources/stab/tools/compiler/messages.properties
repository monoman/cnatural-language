AbstractMemberInClass = ''{1}'' is abstract but it is contained in non-abstract class ''{0}''
AbstractMethodNotImplemented = ''{0}'' does not implement inherited abstract method ''{1}.{2}''
AbstractTypeCreation = Cannot create an instance of the abstract type ''{0}''
AlreadyDefinedConstructor = Type ''{0}'' already defines the same constructor
AlreadyDefinedDestructor = Type ''{0}'' already defines a destructor
AlreadyDefinedField = Type ''{0}'' already defines a field called ''{1}''
AlreadyDefinedMethod = Type ''{0}'' already defines a member called ''{1}'' with the same parameter types
AlreadyDefinedProperty = Type ''{0}'' already defines a property called ''{1}''
AlreadyDefinedStaticInitializer = Type ''{0}'' already defines a static initializer
AlreadyDefinedType = A type ''{0}'' is already defined
AmbiguousMembers = Ambiguity between ''{0}'' and ''{1}''
AmbiguousReference = ''{0}'' is an ambiguous reference between ''{1}'' and ''{2}''
AmbiguousTypeName = The name ''{0}'' represents an ambiguous type name
AnnotationTypeExpected = Type ''{0}'' is not an annotation type
ArrayExpressionExpected = The expression must represent an array
ArrayInitializerTypeMismatch = Cannot implicitly convert all the elements of the array initializer to ''{0}''
ArrayTypeExpected = Array type expected
BaseClassBeforeInterfaces = Base class ''{0}'' must come before any interfaces
BaseMissingConstructor = ''{0}'' does not contain a constructor that takes {1} arguments
BaseMissingDefaultConstructor = ''{0}'' does not contain a constructor without argument
BinaryOperatorNotApplicable = Operator ''{0}'' cannot be applied to operand of type ''{1}'' and ''{2}''
BreakOutsideLoop = No enclosing loop or ''switch'' out of which to break
CannotApplyInvocation = The method ''{0}.{1}'' is not applicable for the arguments {2}
CaseFallThrough = Cannot fall through one case label to another
CastFromNullToPrimitiveType = Cannot cast from a null value to a primitive type
ClassInInterfaceList = Interface ''{0}'' cannot have a base class: ''{1}''
ConditionalExpressionTypeInference = Type of conditional expression cannot be determined
ConditionalMethodNotVoid = A method with a ''Conditional'' annotation must return ''void''
ConstraintNotInterfaceOrFinal = The type constraint ''{0}'' must be a type parameter, an interface or a non-final class
ConstantValueExpected = A constant value is expected
ContinueOutsideLoop = No enclosing loop out of which to continue
CircularBaseTypeDependency = Circular base type dependency involving ''{0}'' and ''{1}''
DelegateCreationInitializer = Object and collection initializer expressions may not be applied to delegate creation expression
DeprecatedField = Usage of deprecated field ''{0}.{1}''
DeprecatedMethod = Usage of deprecated method ''{0}.{1}''
DeprecatedProperty = Usage of deprecated property ''{0}.{1}''
DeprecatedType = Usage of deprecated type ''{0}''
DeriveFromTypeVariable = Cannot derive from ''{0}'' because it is a type variable
DifferentPartialBaseClass = Partial declarations of ''{0}'' must not specify different base classes
DimensionsAndInitializer = Cannot define both dimension expressions and array initializer
DivisionByZero = Division by constant zero
DuplicateCase = The same case already occurs in the ''switch'' statement
EnumCaseNotIdentifier = The ''case'' label must be an identifier
ExpectedExceptionInCref = An exception type was expected in a ''cref'' attribute
ExternalLocalAssignment =  Cannot modify a variable defined outside the current scope from an expression tree
FinalAbstractStaticClass = A class can only be abstract or final or static
FinalAbstractStaticMethod = A method cannot be both abstract and final and static
FinalBaseClass = ''{0}'': cannot derive from final class ''{1}''
FinalFieldModification = A final field cannot be modified, except in constructors and variable initializers
FinalIndexerOverride = Cannot override the final indexer in type ''{0}''
FinalPropertyOverride = Cannot override the final property ''{1}'' in type ''{0}''
FinalVolatile = A field cannot be final and volatile
FinalizeMethodOverride = A class cannot declare a ''finalize'' method. Use the destructor syntax instead
GenericArrayCreation = Specifying an generic parameter type to create an array is unsafe
GenericParameterInCatch = Cannot use the type parameter ''{0}'' in a catch clause
GenericStaticAccess = A raw type may be used to access static members
IllegalGetOrSetBody = The body of an accessor can be empty if the body of the other accessor is also empty
IllegalGetOrSetModifiers = At least one accessor of a property must have the same modifiers as the property
IllegalLeftValue = The left-hand side of an assignment must be a variable, property or indexer
IllegalOverrideMethod = ''{0}.{1}'' cannot override the non-virtual method in ''{2}''
IllegalVirtualMethod = ''{0}.{1}'' cannot be virtual because the same method is declared in type ''{2}''
ImplicitlyTypedArrayTypeNotFound = No best type found for implicitly-typed array
ImplicitVariableWithArrayInitializer = Cannot initialize implicitly-typed variable with an array initializer
IncludeFileNotFound = Documentation include file ''{0}'' cannot be loaded
IncludeFileInvalid = Documentation include file ''{0}'' cannot be parsed
IncludePathInvalid = XPath ''{0}'' cannot be parsed
IncompatibleLambdaInterface = A lambda expression cannot be converted to type ''{0}'' because it does not have a single method
IncompatibleOverridingReturnType = ''{0}.{1}'' has a return type incompatible with the return type of ''{2}.{1}''
IncompatibleParameterList = Type ''{0}'' is not compatible with this lambda expression
InconsistentAccessibility = Type ''{0}'' is less accessible than method ''{1}''
InconsistentBaseTypeAccessibility = Base class ''{1}'' is less accessible than ''{0}''
InconsistentCollectionInitializerTypes = Types of the elements in the collection initializer are inconsistent
IntegerStringOrEnumExpected = An integer, string or enum value is expected
InvalidCast = Cannot convert type ''{0}'' to ''{1}''
InvalidDestructorName = The name ''{0}'' of the destructor does not match the name of its declaring class
InvalidExpressionTreeArgument = stab.tree.ExpressionTree must be parameterized with a delegate type or an interface type
InvalidGotoCase = A ''goto case'' is only valid inside a ''switch'' statement
InvalidLambdaTarget = A lambda expression must be assigned to an interface or a delegate type
InvalidParamElement = The <param> element should be used to document a method or an indexer
InvalidParamNameAttribute = ''{0}'' does not represent a parameter name
InvalidTargetForMemberAccess = The expression does not give access to a member ''{0}''
IntegralConstantTooLarge = Integral constant is too large
LambdaOutsideMethod = Lambda expressions cannot be used inside field initializers
MalformedCollectionInitializer = Malformed collection initializer
MalformedXmlComment = Member ''{0}'' is documented with a malformed XML comment
MethodNameExpected = Method name expected
MethodWithoutBody = ''{0}.{1}'' must declare a body because it is not marked abstract, partial or native
MethodWithoutReturnType = Method ''{0}'' must have a return type
MissingDocAttribute = Missing attribute ''{0}'' on element ''{1}'' in XML comment
MissingImplicitVariableInitializer = Implicitly-typed local variables must be initialized
MissingOverride = ''{0}.{1}'' has the same signature as the method in ''{2}''. Add the ''override'' keyword to redefine this method
MissingOverrideIndexer = Add the ''override'' keyword to redefine the indexer in ''{0}''
MissingOverrideProperty = Add the ''override'' keyword to redefine the property in ''{0}''
MissingReturn = Not all code paths return a value
MultipleBaseClass = Class ''{0}'' cannot have multiple base classes: ''{1}'' and ''{2}''
MultipleImplicitVariableDeclarators = Implicitly-typed local variables cannot have multiple declarators
MultiplePartialDefiningDeclarations = A partial method may not have multiple defining declarations
MultiplePartialImplementingDeclarations = A partial method may not have multiple implementing declarations
MultipleUsingDirective = The using directive for ''{0}'' appeared previously in this namespace
NestedMethodSuperAccess = Access to a member through the ''super'' keyword from lambda expressions, expression trees, and iterator blocks is forbidden
NoAccessibleConstructors = Type ''{0}'' does not contain an accessible constructor with the specified arguments
NoAccessibleMembers = Type ''{1}'' does not contain an accessible ''{0}'' member
NoAddOrPutMethod =  No ''add'' or ''put'' method of ''{0}'' can be called to initialize the object
NoCompatibleIndexerInType = No overload of the indexers in type ''{0}'' can be called with the specified arguments
NoDisposeMethod = A method to dispose instances of type ''{0}'' cannot be found
NoEligibleOverload = No overload for method ''{0}'' can be called using the specified arguments
NoImplicitConversion = Cannot implicitly convert type ''{0}'' to ''{1}''
NoIndexerInType = Cannot apply indexing with [] to an expression of type ''{0}''
NoIndexerToOverride = No suitable indexer found to override in base types of ''{0}''
NoInvocationTargetFound = Cannot apply invocation to any method, delegate or extension method
NoLambdaReturnTypeInference = The return type of the lambda expression cannot be inferred
NoMatchingNumberOfArguments = No method ''{0}'' found with {1} arguments
NoMethodToOverride = No method ''{1}'' found to override in base types of ''{0}''
NoOverridableGetAccessor = Cannot override because ''{0}'' does not have an overridable get accessor
NoOverridableSetAccessor = Cannot override because ''{0}'' does not have an overridable set accessor
NoPropertyToOverride = No property ''{1}'' found to override in base types of ''{0}''
NoPartialImplementingDeclaration = Partial method does not have an implementing declaration
NotGeneratedMethodUsage = Cannot create a delegate to ''{0}'' because it excluded from compilation
NullImplicitVariableInitializer = Cannot assign ''null'' to an implicitly-typed local variable
NullMemberAccess = Cannot access members of ''null''
OverridingDeprecated = ''{0}.{1}'' is overriding a deprecated method of type ''{2}''
PackageAnnotatedExternally = The package ''{0}'' already has annotations in compiled code
ParamsNotArray = ''params'' keyword allowed only on array type arguments
ParamsNotLast = ''params'' keyword allowed only for the last argument of a method
PartialMethodWithinPartialClass = A partial method must be declared within a partial class
PartialMethodNotVoid = Partial methods must have a void return type
PartialTypeArgumentsMismatch = Partial declarations of ''{0}'' must have the same type parameter names in the same order
PrimitiveGenericArgument = A primitive type cannot be used as generic parameter
PublicProtectedPrivate = More than one protection modifier
RawTypeUsage = ''{0}'' is a raw type. ''{1}'' should be used with type parameters
ReadonlyIndexerModification = A read only indexer cannot be assigned to
ReadonlyPropertyModification = A read only property cannot be assigned to
ReduceMethodVisibility = ''{0}.{1}'' reduce the visibility of the method in ''{2}''
ReferenceTypeExpected = Reference type expected
ReferenceTypeValueExpected = Reference type value expected
ReturnInsideIterator = Cannot return from an iterator. Use the ''yield break'' or ''yield return'' statements
ReturnNotVoid = The return type of the current method is not void. The 'return' statement must be followed by an expression
ReturnVoid = The return type of the current method is void. The 'return' statement must not be followed by an expression
StaticClassConstructor = Static classes cannot have instance constructors
StaticClassInstanceMember = Static classes cannot have instance members
StaticSuperAccess = Keyword ''super'' is not valid in a static context
StaticThisAccess = Keyword ''this'' is not valid in a static context
ThisNotFirst = ''this'' keyword allowed only for the first argument of a method
ThisParameterNotStatic = ''this'' keyword allowed only for static methods
TypeArgumentsNonGeneric = The non-generic type ''{0}'' cannot be used with type arguments
TypeExpressionNotAllowed = Cannot directly use a type here
TypeNotFound = Type ''{0}'' cannot be found
TypeofGenericType = Cannot get the runtime class of generic type ''{0}''
TypeofTypeVariable = Cannot get the runtime class of type variable ''{0}''
UnaryOperatorNotApplicable = Operator ''{0}'' cannot applied to operand of type ''{1}''
UnassignedVariableUsage = Use of unassigned local variable ''{0}''
UncheckedCast = A cast from ''{0}'' to ''{1}'' is not checked during runtime
UnexpectedArrayArgument = An array argument cannot be used here
UnexpectedModifier = Modifier ''{0}'' cannot be used here
UnexpectedMethodReference = Method reference cannot be used here
UnexpectedNull = Unexpected ''null'' expression
UninitializedInterfaceField = Interface fields must be initialized
UnknownEnumMember = The name ''{0}'' does not represent a member of enum ''{1}''
UnknownGotoLabel = No such label ''{0}'' within the scope of the ''goto'' statement
UnreachableStatement = Unreachable statement
UnresolvedCref = The name ''{0}'' cannot be resolved in XML comment
UnresolvedLabel = No such label ''{0}'' within the scope of the goto statement
UnresolvedName = The name ''{0}'' cannot be resolved in this context
UnresolvedNestedTypeName = The name ''{1}'' cannot be resolved to a nested type of ''{0}''
UnresolvedStaticName = A static member ''{0}'' cannot be resolved in this context
UnresolvedTypeName = The name ''{0}'' cannot be resolved to a type
UsingVariableUninitialized = The variables of a ''using'' statement must be initialized
ValueParameterConflict = The parameter ''value' conflicts with the generated parameter
VariableRedefinition = A variable named ''{0}'' is already defined in this scope
VariableNeverRead = Variable ''{0}'' is assigned but never read
VariableNeverUsed = Variable ''{0}'' is never used
VariableUninitialized = Variable ''{0}'' is used but never initialized
WildcardTypeCreation = Cannot create an instance of the type ''{0}''
WrongTypeArgumentNumber = The type ''{0}'' requires ''{1}'' type arguments
YieldOutsideIterator = A ''yield'' statement must be used inside an iterator method
